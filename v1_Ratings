#!/usr/bin/env python3
"""
SF Ratings Tracker (multi-select SEC filters + searchable Security)

Reads all Excel files in the current folder starting with "SF" (default: SF*.xlsx),
aggregates them, then tracks rating changes over time on Security level.

Expected (standardized) columns:
- As_of_Date
- Security
- SEC 1
- SEC 2
- SEC 3
- RTG_FITCH_MAPPED
- RTG_MOODY_MAPPED
- RTG_SP_MAPPED
- RTG_DBRS_MAPPED

Exports:
1) Excel workbook:
   - rating_history
   - all_changes
   - downgrades
   - upgrades
2) Interactive HTML (Plotly) with:
   - Month dropdown incl. "ALL"
   - Change Type dropdown
   - SEC 1/2/3 multi-select check lists
   - Security searchable type-in (datalist) + dropdown (select)
   - Line chart of rating time series per agency

Rules:
- 1..22 comparable rating scale (higher = better)
- 23 = N/A, 24 = PIF
- Up/Dn classification only when BOTH before and after are in 1..22
"""

from __future__ import annotations

import argparse
import glob
import json
import os
from typing import Dict, List, Optional, Tuple

import pandas as pd


RATING_COLS = [
    "RTG_FITCH_MAPPED",
    "RTG_MOODY_MAPPED",
    "RTG_SP_MAPPED",
    "RTG_DBRS_MAPPED",
]

# Standardized exact names required by user
DATE_COL = "As_of_Date"
SEC1_COL = "SEC 1"
SEC2_COL = "SEC 2"
SEC3_COL = "SEC 3"

ID_COLS = [DATE_COL, "Security", SEC1_COL, SEC2_COL, SEC3_COL]

SPECIAL = {23: "N/A", 24: "PIF"}


def _clean_name(s: str) -> str:
    return " ".join(str(s).replace("_", " ").split()).strip().lower()


def _standardize_columns(df: pd.DataFrame) -> pd.DataFrame:
    colmap: Dict[str, str] = {}
    for c in df.columns:
        key = _clean_name(c)

        if key in {"as of date", "as_of_date", "as of_date", "asof date", "asof_date"}:
            colmap[c] = DATE_COL
        elif key in {"sec 1", "sec1", "sec_1"}:
            colmap[c] = SEC1_COL
        elif key in {"sec 2", "sec2", "sec_2"}:
            colmap[c] = SEC2_COL
        elif key in {"sec 3", "sec3", "sec_3"}:
            colmap[c] = SEC3_COL
        elif key in {"security"}:
            colmap[c] = "Security"
        elif key == _clean_name("RTG_FITCH_MAPPED"):
            colmap[c] = "RTG_FITCH_MAPPED"
        elif key == _clean_name("RTG_MOODY_MAPPED"):
            colmap[c] = "RTG_MOODY_MAPPED"
        elif key == _clean_name("RTG_SP_MAPPED"):
            colmap[c] = "RTG_SP_MAPPED"
        elif key == _clean_name("RTG_DBRS_MAPPED"):
            colmap[c] = "RTG_DBRS_MAPPED"

    df = df.rename(columns=colmap)
    df = df.rename(columns={c: str(c).strip() for c in df.columns})
    return df


def _parse_date(series: pd.Series) -> pd.Series:
    s = pd.to_datetime(series, errors="coerce")
    return s.dt.normalize()


def _as_int(series: pd.Series) -> pd.Series:
    return pd.to_numeric(series, errors="coerce").round(0).astype("Int64")


def load_all_files(pattern: str, sheet: str | int = 0) -> pd.DataFrame:
    files = sorted(glob.glob(pattern))
    if not files:
        raise FileNotFoundError(f"No files found matching pattern: {pattern}")

    dfs = []
    for fp in files:
        x = pd.read_excel(fp, sheet_name=sheet, dtype="object")
        x = _standardize_columns(x)

        required = ID_COLS + RATING_COLS
        missing = [c for c in required if c not in x.columns]
        if missing:
            raise ValueError(
                f"File '{os.path.basename(fp)}' missing required columns after standardization: {missing}\n"
                f"Columns found: {list(x.columns)}"
            )

        x = x[required].copy()
        x[DATE_COL] = _parse_date(x[DATE_COL])
        x["Security"] = x["Security"].astype(str)

        for c in RATING_COLS:
            x[c] = _as_int(x[c])

        x["__source_file__"] = os.path.basename(fp)
        dfs.append(x)

    df = pd.concat(dfs, ignore_index=True)
    df = df.dropna(subset=[DATE_COL, "Security"])

    df = df.sort_values(["Security", DATE_COL, "__source_file__"])
    df = df.drop_duplicates(subset=["Security", DATE_COL], keep="last")

    return df.sort_values(["Security", DATE_COL]).reset_index(drop=True)


def classify_change(before: Optional[int], after: Optional[int]) -> Tuple[str, Optional[int]]:
    if pd.isna(before) and pd.isna(after):
        return "NO_CHANGE", None
    if before == after:
        return "NO_CHANGE", None

    if before is None or after is None or pd.isna(before) or pd.isna(after):
        return "NON_COMPARABLE", None

    b = int(before)
    a = int(after)

    if 1 <= b <= 22 and 1 <= a <= 22:
        if a > b:
            return "UPGRADE", +1
        if a < b:
            return "DOWNGRADE", -1
        return "NO_CHANGE", None

    return "NON_COMPARABLE", None


def build_change_events(df: pd.DataFrame) -> pd.DataFrame:
    out_rows: List[Dict] = []
    df = df.sort_values(["Security", DATE_COL]).reset_index(drop=True)

    for sec, g in df.groupby("Security", sort=False):
        g = g.sort_values(DATE_COL).reset_index(drop=True)

        for agency_col in RATING_COLS:
            before_series = g[agency_col].shift(1)
            after_series = g[agency_col]

            changed_mask = before_series.ne(after_series) & ~(before_series.isna() & after_series.isna())
            if not changed_mask.any():
                continue

            for idx in g.index[changed_mask]:
                before = before_series.loc[idx]
                after = after_series.loc[idx]
                change_type, direction = classify_change(before, after)

                out_rows.append(
                    {
                        "Security": sec,
                        SEC1_COL: g.loc[idx, SEC1_COL],
                        SEC2_COL: g.loc[idx, SEC2_COL],
                        SEC3_COL: g.loc[idx, SEC3_COL],
                        DATE_COL: g.loc[idx, DATE_COL],
                        "Agency_Column": agency_col,
                        "RTG_MAPPED_before": before,
                        "RTG_MAPPED_after": after,
                        "Change_Type": change_type,
                        "Direction": direction,
                        "Before_Label": SPECIAL.get(int(before), None) if pd.notna(before) else None,
                        "After_Label": SPECIAL.get(int(after), None) if pd.notna(after) else None,
                    }
                )

    changes = pd.DataFrame(out_rows)
    if changes.empty:
        return pd.DataFrame(
            columns=[
                "Security",
                SEC1_COL,
                SEC2_COL,
                SEC3_COL,
                DATE_COL,
                "Agency_Column",
                "RTG_MAPPED_before",
                "RTG_MAPPED_after",
                "Change_Type",
                "Direction",
                "Before_Label",
                "After_Label",
                "YearMonth",
            ]
        )

    changes["YearMonth"] = changes[DATE_COL].dt.strftime("%Y-%m")
    return changes.sort_values([DATE_COL, "Security", "Agency_Column"]).reset_index(drop=True)


def export_excel(df_history: pd.DataFrame, changes: pd.DataFrame, out_xlsx: str) -> None:
    rating_history = df_history.sort_values(["Security", DATE_COL]).copy()

    all_changes = changes.copy()
    downgrades = changes[changes["Change_Type"] == "DOWNGRADE"].copy()
    upgrades = changes[changes["Change_Type"] == "UPGRADE"].copy()

    rating_cols_order = [DATE_COL, "Security", SEC1_COL, SEC2_COL, SEC3_COL] + RATING_COLS
    rating_history = rating_history[rating_cols_order]

    change_cols_order = [
        DATE_COL,
        "YearMonth",
        "Security",
        SEC1_COL,
        SEC2_COL,
        SEC3_COL,
        "Agency_Column",
        "RTG_MAPPED_before",
        "RTG_MAPPED_after",
        "Change_Type",
        "Direction",
        "Before_Label",
        "After_Label",
    ]
    all_changes = all_changes.reindex(columns=change_cols_order)
    downgrades = downgrades.reindex(columns=change_cols_order)
    upgrades = upgrades.reindex(columns=change_cols_order)

    with pd.ExcelWriter(out_xlsx, engine="openpyxl") as w:
        rating_history.to_excel(w, index=False, sheet_name="rating_history")
        all_changes.to_excel(w, index=False, sheet_name="all_changes")
        downgrades.to_excel(w, index=False, sheet_name="downgrades")
        upgrades.to_excel(w, index=False, sheet_name="upgrades")


def build_interactive_html(df_history: pd.DataFrame, changes: pd.DataFrame, out_html: str) -> None:
    hist = df_history.sort_values(["Security", DATE_COL]).copy()
    hist["As_of_Date_str"] = hist[DATE_COL].dt.strftime("%Y-%m-%d")

    meta = (
        hist.sort_values(["Security", DATE_COL])
        .groupby("Security", as_index=False)[[SEC1_COL, SEC2_COL, SEC3_COL]]
        .last()
    )

    series_by_security: Dict[str, Dict] = {}
    for sec, g in hist.groupby("Security", sort=False):
        series_by_security[sec] = {
            "dates": g["As_of_Date_str"].tolist(),
            "ratings": {c: [None if pd.isna(v) else int(v) for v in g[c].tolist()] for c in RATING_COLS},
        }

    ch = changes.copy()
    if not ch.empty:
        bucket = (
            ch.assign(_flag=1)
            .groupby(["YearMonth", "Change_Type", "Security"], as_index=False)["_flag"]
            .sum()
        )
        bucket_any = (
            ch.assign(_flag=1)
            .groupby(["YearMonth", "Security"], as_index=False)["_flag"]
            .sum()
        )
        bucket_any["Change_Type"] = "ANY"
        bucket = pd.concat([bucket, bucket_any], ignore_index=True)
    else:
        bucket = pd.DataFrame(columns=["YearMonth", "Change_Type", "Security"])

    months = sorted(hist[DATE_COL].dt.strftime("%Y-%m").dropna().unique().tolist())
    months = ["ALL"] + months if months else ["ALL"]

    # Build options for SECs (strings for HTML)
    sec1_opts = sorted(meta[SEC1_COL].dropna().astype(str).unique().tolist())
    sec2_opts = sorted(meta[SEC2_COL].dropna().astype(str).unique().tolist())
    sec3_opts = sorted(meta[SEC3_COL].dropna().astype(str).unique().tolist())

    payload = {
        "months": months,
        "series_by_security": series_by_security,
        "bucket_rows": bucket[["YearMonth", "Change_Type", "Security"]].to_dict("records"),
        "meta_rows": meta.assign(
            **{
                SEC1_COL: meta[SEC1_COL].astype(str),
                SEC2_COL: meta[SEC2_COL].astype(str),
                SEC3_COL: meta[SEC3_COL].astype(str),
            }
        )[["Security", SEC1_COL, SEC2_COL, SEC3_COL]].to_dict("records"),
        "sec1_opts": sec1_opts,
        "sec2_opts": sec2_opts,
        "sec3_opts": sec3_opts,
        "rating_cols": RATING_COLS,
    }

    html = f"""<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>SF Ratings Tracker</title>
  <script src="https://cdn.plot.ly/plotly-2.30.0.min.js"></script>
  <style>
    body {{ font-family: Arial, sans-serif; margin: 18px; }}
    .row {{ display: flex; gap: 16px; flex-wrap: wrap; align-items: flex-start; }}
    .control {{ display: flex; flex-direction: column; min-width: 220px; }}
    label {{ font-size: 12px; color: #444; margin-bottom: 4px; }}
    select, input {{ padding: 6px; }}
    #chart {{ width: 100%; height: 640px; margin-top: 14px; }}
    .hint {{ color: #666; font-size: 12px; margin-top: 10px; }}
    .badge {{ display: inline-block; padding: 2px 8px; border: 1px solid #ccc; border-radius: 12px; font-size: 12px; margin-left: 8px; }}
    .box {{
      border: 1px solid #ddd; border-radius: 8px; padding: 8px;
      max-height: 180px; overflow: auto; background: #fafafa;
    }}
    .box label {{ display: flex; gap: 8px; align-items: center; margin: 2px 0; font-size: 12px; color: #222; }}
    .small {{ font-size: 12px; color: #666; margin-top: 4px; }}
    .wide {{ min-width: 360px; }}
    .btnrow {{ display: flex; gap: 8px; margin-top: 6px; }}
    button {{ padding: 6px 10px; cursor: pointer; }}
  </style>
</head>
<body>
  <h2>SF Ratings Tracker (Interactive)</h2>

  <div class="row">
    <div class="control">
      <label>Month ({DATE_COL})</label>
      <select id="monthSelect"></select>
    </div>

    <div class="control">
      <label>Change Type</label>
      <select id="typeSelect">
        <option value="ANY">Any (all change types)</option>
        <option value="UPGRADE">Upgrade</option>
        <option value="DOWNGRADE">Downgrade</option>
      </select>
    </div>

    <div class="control">
      <label>{SEC1_COL} (multi-select)</label>
      <div class="btnrow">
        <button type="button" id="sec1All">All</button>
        <button type="button" id="sec1None">None</button>
      </div>
      <div id="sec1Box" class="box"></div>
      <div class="small">Checked = included. None checked means “all”.</div>
    </div>

    <div class="control">
      <label>{SEC2_COL} (multi-select)</label>
      <div class="btnrow">
        <button type="button" id="sec2All">All</button>
        <button type="button" id="sec2None">None</button>
      </div>
      <div id="sec2Box" class="box"></div>
      <div class="small">Checked = included. None checked means “all”.</div>
    </div>

    <div class="control">
      <label>{SEC3_COL} (multi-select)</label>
      <div class="btnrow">
        <button type="button" id="sec3All">All</button>
        <button type="button" id="sec3None">None</button>
      </div>
      <div id="sec3Box" class="box"></div>
      <div class="small">Checked = included. None checked means “all”.</div>
    </div>

    <div class="control wide">
      <label>Security (type to search)</label>
      <input id="securityInput" list="securityDatalist" placeholder="Start typing Security..." />
      <datalist id="securityDatalist"></datalist>
      <div class="small">Pick from list or type exact Security; chart uses current selection below.</div>

      <label style="margin-top:10px;">Security (filtered list)</label>
      <select id="securitySelect"></select>
    </div>
  </div>

  <div class="hint">
    Notes:
    <span class="badge">1..22 comparable</span>
    <span class="badge">23 = N/A</span>
    <span class="badge">24 = PIF</span>
    <span class="badge">Up/Dn only when both 1..22</span>
  </div>

  <div id="chart"></div>

<script>
const DATA = {json.dumps(payload)};

const monthSelect = document.getElementById("monthSelect");
const typeSelect = document.getElementById("typeSelect");

const sec1Box = document.getElementById("sec1Box");
const sec2Box = document.getElementById("sec2Box");
const sec3Box = document.getElementById("sec3Box");

const sec1AllBtn = document.getElementById("sec1All");
const sec1NoneBtn = document.getElementById("sec1None");
const sec2AllBtn = document.getElementById("sec2All");
const sec2NoneBtn = document.getElementById("sec2None");
const sec3AllBtn = document.getElementById("sec3All");
const sec3NoneBtn = document.getElementById("sec3None");

const securityInput = document.getElementById("securityInput");
const securityDatalist = document.getElementById("securityDatalist");
const securitySelect = document.getElementById("securitySelect");

function setOptions(selectEl, values) {{
  selectEl.innerHTML = "";
  for (const v of values) {{
    const opt = document.createElement("option");
    opt.value = v;
    opt.textContent = v;
    selectEl.appendChild(opt);
  }}
}}

function fillMonth() {{
  setOptions(monthSelect, DATA.months);
}}

fillMonth();

const metaBySecurity = new Map();
for (const row of DATA.meta_rows) {{
  metaBySecurity.set(row.Security, row);
}}

function buildChecklist(container, values, groupName) {{
  container.innerHTML = "";
  for (const v of values) {{
    const id = groupName + "_" + String(v).replace(/[^a-zA-Z0-9]/g, "_");
    const wrap = document.createElement("label");
    const cb = document.createElement("input");
    cb.type = "checkbox";
    cb.value = v;
    cb.dataset.group = groupName;
    cb.addEventListener("change", refreshSecurityList);
    wrap.appendChild(cb);
    const t = document.createElement("span");
    t.textContent = v;
    wrap.appendChild(t);
    container.appendChild(wrap);
  }}
}}

buildChecklist(sec1Box, DATA.sec1_opts, "sec1");
buildChecklist(sec2Box, DATA.sec2_opts, "sec2");
buildChecklist(sec3Box, DATA.sec3_opts, "sec3");

function setAll(container, checked) {{
  const boxes = container.querySelectorAll("input[type=checkbox]");
  boxes.forEach(cb => cb.checked = checked);
}}

sec1AllBtn.addEventListener("click", () => {{ setAll(sec1Box, true); refreshSecurityList(); }});
sec1NoneBtn.addEventListener("click", () => {{ setAll(sec1Box, false); refreshSecurityList(); }});
sec2AllBtn.addEventListener("click", () => {{ setAll(sec2Box, true); refreshSecurityList(); }});
sec2NoneBtn.addEventListener("click", () => {{ setAll(sec2Box, false); refreshSecurityList(); }});
sec3AllBtn.addEventListener("click", () => {{ setAll(sec3Box, true); refreshSecurityList(); }});
sec3NoneBtn.addEventListener("click", () => {{ setAll(sec3Box, false); refreshSecurityList(); }});

function selectedValues(container) {{
  const boxes = Array.from(container.querySelectorAll("input[type=checkbox]"));
  const checked = boxes.filter(cb => cb.checked).map(cb => cb.value);
  // None checked => treat as "all"
  return checked;
}}

function eligibleSecuritiesByMonthType(month, changeType) {{
  // If no changes data, allow all securities
  if (!DATA.bucket_rows || DATA.bucket_rows.length === 0) {{
    return Object.keys(DATA.series_by_security);
  }}

  const secSet = new Set();

  // "ALL" means any month, but still respect Change Type
  if (month === "ALL") {{
    for (const row of DATA.bucket_rows) {{
      if (row.Change_Type === changeType) {{
        secSet.add(row.Security);
      }}
    }}
    return Array.from(secSet);
  }}

  for (const row of DATA.bucket_rows) {{
    if (row.YearMonth === month && row.Change_Type === changeType) {{
      secSet.add(row.Security);
    }}
  }}
  return Array.from(secSet);
}}

function applySecFilters(securities) {{
  const f1 = selectedValues(sec1Box);
  const f2 = selectedValues(sec2Box);
  const f3 = selectedValues(sec3Box);

  const use1 = f1.length > 0;
  const use2 = f2.length > 0;
  const use3 = f3.length > 0;

  return securities.filter(sec => {{
    const metaRow = metaBySecurity.get(sec);
    if (!metaRow) return false;

    const v1 = String(metaRow["{SEC1_COL}"]);
    const v2 = String(metaRow["{SEC2_COL}"]);
    const v3 = String(metaRow["{SEC3_COL}"]);

    if (use1 && !f1.includes(v1)) return false;
    if (use2 && !f2.includes(v2)) return false;
    if (use3 && !f3.includes(v3)) return false;
    return true;
  }});
}}

function refreshDatalist(secs) {{
  securityDatalist.innerHTML = "";
  for (const s of secs) {{
    const opt = document.createElement("option");
    opt.value = s;
    securityDatalist.appendChild(opt);
  }}
}}

function syncSelectToInputIfPossible() {{
  const typed = securityInput.value;
  if (!typed) return;
  const options = Array.from(securitySelect.options).map(o => o.value);
  if (options.includes(typed)) {{
    securitySelect.value = typed;
    renderChart();
  }}
}}

function refreshSecurityList() {{
  const month = monthSelect.value;
  const type = typeSelect.value;

  let secs = eligibleSecuritiesByMonthType(month, type);
  secs = applySecFilters(secs).sort();

  setOptions(securitySelect, secs);
  refreshDatalist(secs);

  if (secs.length === 0) {{
    Plotly.purge("chart");
    document.getElementById("chart").innerHTML = "<p>No securities match the selected Month/Type/SEC filters.</p>";
    return;
  }}

  // keep current selection if possible
  const current = securitySelect.value;
  if (!current || !secs.includes(current)) {{
    securitySelect.value = secs[0];
  }}

  // If user typed something valid, prefer it
  const typed = securityInput.value;
  if (typed && secs.includes(typed)) {{
    securitySelect.value = typed;
  }}

  renderChart();
}}

function renderChart() {{
  const sec = securitySelect.value;
  const item = DATA.series_by_security[sec];
  if (!item) return;

  const dates = item.dates;

  const traces = [];
  for (const col of DATA.rating_cols) {{
    traces.push({{
      x: dates,
      y: item.ratings[col],
      mode: "lines+markers",
      name: col,
      connectgaps: false
    }});
  }}

  const titleParts = [sec];
  const metaRow = metaBySecurity.get(sec);
  if (metaRow) {{
    titleParts.push(
      "{SEC1_COL}=" + metaRow["{SEC1_COL}"],
      "{SEC2_COL}=" + metaRow["{SEC2_COL}"],
      "{SEC3_COL}=" + metaRow["{SEC3_COL}"]
    );
  }}

  const layout = {{
    title: titleParts.join("  |  "),
    xaxis: {{ title: "{DATE_COL}" }},
    yaxis: {{ title: "Mapped Rating (1..22 scale, 23=N/A, 24=PIF)" }},
    legend: {{ orientation: "h" }},
    margin: {{ t: 70, r: 30, b: 60, l: 80 }},
    hovermode: "x unified"
  }};

  Plotly.newPlot("chart", traces, layout, {{responsive: true}});
}}

monthSelect.addEventListener("change", refreshSecurityList);
typeSelect.addEventListener("change", refreshSecurityList);

// Security type-in behavior
securityInput.addEventListener("change", () => {{
  // If typed matches, select it
  syncSelectToInputIfPossible();
}});
securityInput.addEventListener("keyup", () => {{
  // live sync when it becomes exact match
  syncSelectToInputIfPossible();
}});

securitySelect.addEventListener("change", () => {{
  securityInput.value = securitySelect.value; // keep input in sync
  renderChart();
}});

// Initial load
refreshSecurityList();
securityInput.value = securitySelect.value;
</script>
</body>
</html>
"""

    with open(out_html, "w", encoding="utf-8") as f:
        f.write(html)


def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--pattern", default="SF*.xlsx", help="File glob pattern (default: SF*.xlsx)")
    ap.add_argument("--sheet", default=0, help="Sheet name or index (default: 0)")
    ap.add_argument("--out-xlsx", default="SF_Rating_Tracking_Output.xlsx", help="Output Excel filename")
    ap.add_argument("--out-html", default="SF_Rating_Tracking_Interactive.html", help="Output HTML filename")
    args = ap.parse_args()

    df = load_all_files(args.pattern, sheet=args.sheet)
    changes = build_change_events(df)

    export_excel(df, changes, args.out_xlsx)
    build_interactive_html(df, changes, args.out_html)

    print("Done.")
    print(f"Excel written to: {os.path.abspath(args.out_xlsx)}")
    print(f"HTML written to:  {os.path.abspath(args.out_html)}")
    print(f"Rows in history:  {len(df):,}")
    print(f"Change events:    {len(changes):,}")


if __name__ == "__main__":
    main()
