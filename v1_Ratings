#!/usr/bin/env python3
"""
SF Ratings Tracker (full script)

Reads all Excel files in the current folder starting with "SF" (default: SF*.xlsx),
aggregates them, then tracks rating changes over time on Security level.

Expected (standardized) columns:
- As_of_Date
- Security
- SEC 1
- SEC 2
- SEC 3
- RTG_FITCH_MAPPED
- RTG_MOODY_MAPPED
- RTG_SP_MAPPED
- RTG_DBRS_MAPPED

Exports:
1) Excel workbook:
   - rating_history
   - all_changes
   - downgrades
   - upgrades
2) Interactive HTML (Plotly) with Month + Upgrade/Downgrade/Any + SEC filters + Security selection.
   - Month dropdown includes "ALL" (across any month)

Rules:
- 1..22 comparable rating scale (higher = better)
- 23 = N/A, 24 = PIF
- Up/Dn classification only when BOTH before and after are in 1..22
- "Any" in the UI includes all change types (incl. NON_COMPARABLE and NO_CHANGE is not emitted as an event)
"""

from __future__ import annotations

import argparse
import glob
import json
import os
from typing import Dict, List, Optional, Tuple

import pandas as pd


RATING_COLS = [
    "RTG_FITCH_MAPPED",
    "RTG_MOODY_MAPPED",
    "RTG_SP_MAPPED",
    "RTG_DBRS_MAPPED",
]

# Standardized exact names required by user
DATE_COL = "As_of_Date"
SEC1_COL = "SEC 1"
SEC2_COL = "SEC 2"
SEC3_COL = "SEC 3"

ID_COLS = [DATE_COL, "Security", SEC1_COL, SEC2_COL, SEC3_COL]

SPECIAL = {23: "N/A", 24: "PIF"}


def _clean_name(s: str) -> str:
    """Lowercase + collapse whitespace/underscores for robust matching."""
    return " ".join(str(s).replace("_", " ").split()).strip().lower()


def _standardize_columns(df: pd.DataFrame) -> pd.DataFrame:
    """
    Renames input columns (any casing/underscore/whitespace variants) to exact required names:
    As_of_Date, SEC 1, SEC 2, SEC 3, Security, and rating columns.
    """
    colmap: Dict[str, str] = {}
    for c in df.columns:
        key = _clean_name(c)

        if key in {"as of date", "as_of_date", "as of_date", "asof date", "asof_date"}:
            colmap[c] = DATE_COL
        elif key in {"sec 1", "sec1", "sec_1"}:
            colmap[c] = SEC1_COL
        elif key in {"sec 2", "sec2", "sec_2"}:
            colmap[c] = SEC2_COL
        elif key in {"sec 3", "sec3", "sec_3"}:
            colmap[c] = SEC3_COL
        elif key in {"security"}:
            colmap[c] = "Security"
        elif key == _clean_name("RTG_FITCH_MAPPED"):
            colmap[c] = "RTG_FITCH_MAPPED"
        elif key == _clean_name("RTG_MOODY_MAPPED"):
            colmap[c] = "RTG_MOODY_MAPPED"
        elif key == _clean_name("RTG_SP_MAPPED"):
            colmap[c] = "RTG_SP_MAPPED"
        elif key == _clean_name("RTG_DBRS_MAPPED"):
            colmap[c] = "RTG_DBRS_MAPPED"

    df = df.rename(columns=colmap)

    # Strip exact column names too (in case of trailing spaces)
    df = df.rename(columns={c: str(c).strip() for c in df.columns})

    return df


def _parse_date(series: pd.Series) -> pd.Series:
    s = pd.to_datetime(series, errors="coerce")
    return s.dt.normalize()


def _as_int(series: pd.Series) -> pd.Series:
    return pd.to_numeric(series, errors="coerce").round(0).astype("Int64")


def load_all_files(pattern: str, sheet: str | int = 0) -> pd.DataFrame:
    files = sorted(glob.glob(pattern))
    if not files:
        raise FileNotFoundError(f"No files found matching pattern: {pattern}")

    dfs = []
    for fp in files:
        x = pd.read_excel(fp, sheet_name=sheet, dtype="object")
        x = _standardize_columns(x)

        required = ID_COLS + RATING_COLS
        missing = [c for c in required if c not in x.columns]
        if missing:
            raise ValueError(
                f"File '{os.path.basename(fp)}' missing required columns after standardization: {missing}\n"
                f"Columns found: {list(x.columns)}"
            )

        x = x[required].copy()
        x[DATE_COL] = _parse_date(x[DATE_COL])
        x["Security"] = x["Security"].astype(str)

        for c in RATING_COLS:
            x[c] = _as_int(x[c])

        x["__source_file__"] = os.path.basename(fp)
        dfs.append(x)

    df = pd.concat(dfs, ignore_index=True)

    df = df.dropna(subset=[DATE_COL, "Security"])

    # If same Security+Date exists multiple times, keep last occurrence (latest file order)
    df = df.sort_values(["Security", DATE_COL, "__source_file__"])
    df = df.drop_duplicates(subset=["Security", DATE_COL], keep="last")

    return df.sort_values(["Security", DATE_COL]).reset_index(drop=True)


def classify_change(before: Optional[int], after: Optional[int]) -> Tuple[str, Optional[int]]:
    if pd.isna(before) and pd.isna(after):
        return "NO_CHANGE", None
    if before == after:
        return "NO_CHANGE", None

    if before is None or after is None or pd.isna(before) or pd.isna(after):
        return "NON_COMPARABLE", None

    b = int(before)
    a = int(after)

    if 1 <= b <= 22 and 1 <= a <= 22:
        if a > b:
            return "UPGRADE", +1
        if a < b:
            return "DOWNGRADE", -1
        return "NO_CHANGE", None

    return "NON_COMPARABLE", None


def build_change_events(df: pd.DataFrame) -> pd.DataFrame:
    out_rows: List[Dict] = []

    df = df.sort_values(["Security", DATE_COL]).reset_index(drop=True)

    for sec, g in df.groupby("Security", sort=False):
        g = g.sort_values(DATE_COL).reset_index(drop=True)

        for agency_col in RATING_COLS:
            before_series = g[agency_col].shift(1)
            after_series = g[agency_col]

            changed_mask = before_series.ne(after_series) & ~(before_series.isna() & after_series.isna())
            if not changed_mask.any():
                continue

            for idx in g.index[changed_mask]:
                before = before_series.loc[idx]
                after = after_series.loc[idx]
                change_type, direction = classify_change(before, after)

                out_rows.append(
                    {
                        "Security": sec,
                        SEC1_COL: g.loc[idx, SEC1_COL],
                        SEC2_COL: g.loc[idx, SEC2_COL],
                        SEC3_COL: g.loc[idx, SEC3_COL],
                        DATE_COL: g.loc[idx, DATE_COL],
                        "Agency_Column": agency_col,
                        "RTG_MAPPED_before": before,
                        "RTG_MAPPED_after": after,
                        "Change_Type": change_type,
                        "Direction": direction,
                        "Before_Label": SPECIAL.get(int(before), None) if pd.notna(before) else None,
                        "After_Label": SPECIAL.get(int(after), None) if pd.notna(after) else None,
                    }
                )

    changes = pd.DataFrame(out_rows)
    if changes.empty:
        return pd.DataFrame(
            columns=[
                "Security",
                SEC1_COL,
                SEC2_COL,
                SEC3_COL,
                DATE_COL,
                "Agency_Column",
                "RTG_MAPPED_before",
                "RTG_MAPPED_after",
                "Change_Type",
                "Direction",
                "Before_Label",
                "After_Label",
                "YearMonth",
            ]
        )

    changes["YearMonth"] = changes[DATE_COL].dt.strftime("%Y-%m")
    return changes.sort_values([DATE_COL, "Security", "Agency_Column"]).reset_index(drop=True)


def export_excel(df_history: pd.DataFrame, changes: pd.DataFrame, out_xlsx: str) -> None:
    rating_history = df_history.sort_values(["Security", DATE_COL]).copy()

    all_changes = changes.copy()
    downgrades = changes[changes["Change_Type"] == "DOWNGRADE"].copy()
    upgrades = changes[changes["Change_Type"] == "UPGRADE"].copy()

    rating_cols_order = [DATE_COL, "Security", SEC1_COL, SEC2_COL, SEC3_COL] + RATING_COLS
    rating_history = rating_history[rating_cols_order]

    change_cols_order = [
        DATE_COL,
        "YearMonth",
        "Security",
        SEC1_COL,
        SEC2_COL,
        SEC3_COL,
        "Agency_Column",
        "RTG_MAPPED_before",
        "RTG_MAPPED_after",
        "Change_Type",
        "Direction",
        "Before_Label",
        "After_Label",
    ]
    all_changes = all_changes.reindex(columns=change_cols_order)
    downgrades = downgrades.reindex(columns=change_cols_order)
    upgrades = upgrades.reindex(columns=change_cols_order)

    with pd.ExcelWriter(out_xlsx, engine="openpyxl") as w:
        rating_history.to_excel(w, index=False, sheet_name="rating_history")
        all_changes.to_excel(w, index=False, sheet_name="all_changes")
        downgrades.to_excel(w, index=False, sheet_name="downgrades")
        upgrades.to_excel(w, index=False, sheet_name="upgrades")


def build_interactive_html(df_history: pd.DataFrame, changes: pd.DataFrame, out_html: str) -> None:
    hist = df_history.sort_values(["Security", DATE_COL]).copy()
    hist["As_of_Date_str"] = hist[DATE_COL].dt.strftime("%Y-%m-%d")

    # latest SEC fields per security
    meta = (
        hist.sort_values(["Security", DATE_COL])
        .groupby("Security", as_index=False)[[SEC1_COL, SEC2_COL, SEC3_COL]]
        .last()
    )

    series_by_security: Dict[str, Dict] = {}
    for sec, g in hist.groupby("Security", sort=False):
        series_by_security[sec] = {
            "dates": g["As_of_Date_str"].tolist(),
            "ratings": {c: [None if pd.isna(v) else int(v) for v in g[c].tolist()] for c in RATING_COLS},
        }

    # buckets of eligible securities by YearMonth & Change_Type (any agency)
    ch = changes.copy()
    if not ch.empty:
        bucket = (
            ch.assign(_flag=1)
            .groupby(["YearMonth", "Change_Type", "Security"], as_index=False)["_flag"]
            .sum()
        )

        bucket_any = (
            ch.assign(_flag=1)
            .groupby(["YearMonth", "Security"], as_index=False)["_flag"]
            .sum()
        )
        bucket_any["Change_Type"] = "ANY"
        bucket = pd.concat([bucket, bucket_any], ignore_index=True)
    else:
        bucket = pd.DataFrame(columns=["YearMonth", "Change_Type", "Security"])

    # Month list + ALL option
    months = sorted(hist[DATE_COL].dt.strftime("%Y-%m").dropna().unique().tolist())
    months = ["ALL"] + months if months else ["ALL"]

    sec1_opts = sorted(meta[SEC1_COL].dropna().astype(str).unique().tolist())
    sec2_opts = sorted(meta[SEC2_COL].dropna().astype(str).unique().tolist())
    sec3_opts = sorted(meta[SEC3_COL].dropna().astype(str).unique().tolist())

    payload = {
        "months": months,
        "series_by_security": series_by_security,
        "bucket_rows": bucket[["YearMonth", "Change_Type", "Security"]].to_dict("records"),
        "meta_rows": meta.assign(
            **{
                SEC1_COL: meta[SEC1_COL].astype(str),
                SEC2_COL: meta[SEC2_COL].astype(str),
                SEC3_COL: meta[SEC3_COL].astype(str),
            }
        )[["Security", SEC1_COL, SEC2_COL, SEC3_COL]].to_dict("records"),
        "sec1_opts": sec1_opts,
        "sec2_opts": sec2_opts,
        "sec3_opts": sec3_opts,
        "rating_cols": RATING_COLS,
    }

    html = f"""<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>SF Ratings Tracker</title>
  <script src="https://cdn.plot.ly/plotly-2.30.0.min.js"></script>
  <style>
    body {{ font-family: Arial, sans-serif; margin: 18px; }}
    .row {{ display: flex; gap: 16px; flex-wrap: wrap; align-items: end; }}
    .control {{ display: flex; flex-direction: column; min-width: 220px; }}
    label {{ font-size: 12px; color: #444; margin-bottom: 4px; }}
    select {{ padding: 6px; }}
    #chart {{ width: 100%; height: 640px; }}
    .hint {{ color: #666; font-size: 12px; margin-top: 10px; }}
    .badge {{ display: inline-block; padding: 2px 8px; border: 1px solid #ccc; border-radius: 12px; font-size: 12px; margin-left: 8px; }}
  </style>
</head>
<body>
  <h2>SF Ratings Tracker (Interactive)</h2>

  <div class="row">
    <div class="control">
      <label>Month ({DATE_COL})</label>
      <select id="monthSelect"></select>
    </div>

    <div class="control">
      <label>Change Type</label>
      <select id="typeSelect">
        <option value="ANY">Any (all change types)</option>
        <option value="UPGRADE">Upgrade</option>
        <option value="DOWNGRADE">Downgrade</option>
      </select>
    </div>

    <div class="control">
      <label>{SEC1_COL} (optional filter)</label>
      <select id="sec1Select"><option value="">(all)</option></select>
    </div>

    <div class="control">
      <label>{SEC2_COL} (optional filter)</label>
      <select id="sec2Select"><option value="">(all)</option></select>
    </div>

    <div class="control">
      <label>{SEC3_COL} (optional filter)</label>
      <select id="sec3Select"><option value="">(all)</option></select>
    </div>

    <div class="control" style="min-width: 360px;">
      <label>Security (filtered)</label>
      <select id="securitySelect"></select>
    </div>
  </div>

  <div class="hint">
    Notes:
    <span class="badge">1..22 comparable</span>
    <span class="badge">23 = N/A</span>
    <span class="badge">24 = PIF</span>
    <span class="badge">Up/Dn only when both 1..22</span>
  </div>

  <div id="chart"></div>

<script>
const DATA = {json.dumps(payload)};

const monthSelect = document.getElementById("monthSelect");
const typeSelect = document.getElementById("typeSelect");
const sec1Select = document.getElementById("sec1Select");
const sec2Select = document.getElementById("sec2Select");
const sec3Select = document.getElementById("sec3Select");
const securitySelect = document.getElementById("securitySelect");

function setOptions(selectEl, values, includeBlank=false, blankLabel="(all)") {{
  selectEl.innerHTML = "";
  if (includeBlank) {{
    const opt = document.createElement("option");
    opt.value = "";
    opt.textContent = blankLabel;
    selectEl.appendChild(opt);
  }}
  for (const v of values) {{
    const opt = document.createElement("option");
    opt.value = v;
    opt.textContent = v;
    selectEl.appendChild(opt);
  }}
}}

setOptions(monthSelect, DATA.months);
setOptions(sec1Select, DATA.sec1_opts, true);
setOptions(sec2Select, DATA.sec2_opts, true);
setOptions(sec3Select, DATA.sec3_opts, true);

const metaBySecurity = new Map();
for (const row of DATA.meta_rows) {{
  metaBySecurity.set(row.Security, row);
}}

function eligibleSecuritiesByMonthType(month, changeType) {{
  // If no changes data, allow all securities
  if (!DATA.bucket_rows || DATA.bucket_rows.length === 0) {{
    return Object.keys(DATA.series_by_security);
  }}

  const secSet = new Set();

  // "ALL" means: any month, but still respect Change Type
  if (month === "ALL") {{
    for (const row of DATA.bucket_rows) {{
      if (row.Change_Type === changeType) {{
        secSet.add(row.Security);
      }}
    }}
    return Array.from(secSet);
  }}

  // Normal month filtering
  for (const row of DATA.bucket_rows) {{
    if (row.YearMonth === month && row.Change_Type === changeType) {{
      secSet.add(row.Security);
    }}
  }}
  return Array.from(secSet);
}}

function applySecFilters(securities) {{
  const f1 = sec1Select.value;
  const f2 = sec2Select.value;
  const f3 = sec3Select.value;

  return securities.filter(sec => {{
    const metaRow = metaBySecurity.get(sec);
    if (!metaRow) return false;
    if (f1 && String(metaRow["{SEC1_COL}"]) !== f1) return false;
    if (f2 && String(metaRow["{SEC2_COL}"]) !== f2) return false;
    if (f3 && String(metaRow["{SEC3_COL}"]) !== f3) return false;
    return true;
  }});
}}

function refreshSecurityList() {{
  const month = monthSelect.value;
  const type = typeSelect.value;

  let secs = eligibleSecuritiesByMonthType(month, type);
  secs = applySecFilters(secs).sort();

  setOptions(securitySelect, secs);

  if (secs.length === 0) {{
    Plotly.purge("chart");
    document.getElementById("chart").innerHTML = "<p>No securities match the selected Month/Type/SEC filters.</p>";
    return;
  }}

  if (!securitySelect.value || !secs.includes(securitySelect.value)) {{
    securitySelect.value = secs[0];
  }}
  renderChart();
}}

function renderChart() {{
  const sec = securitySelect.value;
  const item = DATA.series_by_security[sec];
  if (!item) return;

  const dates = item.dates;

  const traces = [];
  for (const col of DATA.rating_cols) {{
    traces.push({{
      x: dates,
      y: item.ratings[col],
      mode: "lines+markers",
      name: col,
      connectgaps: false
    }});
  }}

  const titleParts = [sec];
  const metaRow = metaBySecurity.get(sec);
  if (metaRow) {{
    titleParts.push(
      "{SEC1_COL}=" + metaRow["{SEC1_COL}"],
      "{SEC2_COL}=" + metaRow["{SEC2_COL}"],
      "{SEC3_COL}=" + metaRow["{SEC3_COL}"]
    );
  }}

  const layout = {{
    title: titleParts.join("  |  "),
    xaxis: {{ title: "{DATE_COL}" }},
    yaxis: {{ title: "Mapped Rating (1..22 scale, 23=N/A, 24=PIF)" }},
    legend: {{ orientation: "h" }},
    margin: {{ t: 70, r: 30, b: 60, l: 80 }},
    hovermode: "x unified"
  }};

  Plotly.newPlot("chart", traces, layout, {{responsive: true}});
}}

monthSelect.addEventListener("change", refreshSecurityList);
typeSelect.addEventListener("change", refreshSecurityList);
sec1Select.addEventListener("change", refreshSecurityList);
sec2Select.addEventListener("change", refreshSecurityList);
sec3Select.addEventListener("change", refreshSecurityList);
securitySelect.addEventListener("change", renderChart);

refreshSecurityList();
</script>
</body>
</html>
"""

    with open(out_html, "w", encoding="utf-8") as f:
        f.write(html)


def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--pattern", default="SF*.xlsx", help="File glob pattern (default: SF*.xlsx)")
    ap.add_argument("--sheet", default=0, help="Sheet name or index (default: 0)")
    ap.add_argument("--out-xlsx", default="SF_Rating_Tracking_Output.xlsx", help="Output Excel filename")
    ap.add_argument("--out-html", default="SF_Rating_Tracking_Interactive.html", help="Output HTML filename")
    args = ap.parse_args()

    df = load_all_files(args.pattern, sheet=args.sheet)
    changes = build_change_events(df)

    export_excel(df, changes, args.out_xlsx)
    build_interactive_html(df, changes, args.out_html)

    print("Done.")
    print(f"Excel written to: {os.path.abspath(args.out_xlsx)}")
    print(f"HTML written to:  {os.path.abspath(args.out_html)}")
    print(f"Rows in history:  {len(df):,}")
    print(f"Change events:    {len(changes):,}")


if __name__ == "__main__":
    main()
